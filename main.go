package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type route struct {
	Method     string
	RoutePath  string
	ImportPath string
	Alias      string
	Handler    string
	Group      string
}

func main() {
	src := flag.String("api", "api", "directory of API handlers")
	out := flag.String("out", "routes_gen.go", "output file")
	pkg := flag.String("pkg", "main", "package name for generated file")
	importPre := flag.String("importPREFIX", "", "module import prefix for api")
	middlewarePkg := flag.String("middleware", "", "package containing middleware functions")
	middlewares := flag.String("middlewares", "loggingMiddleware", "comma-separated list of middleware functions to apply globally")
	groupMiddlewares := flag.String("groupMiddlewares", "", "JSON mapping of group to middleware functions, e.g., '{\"users\":\"authMiddleware,rateLimit\"}'")
	notFoundHandler := flag.String("notFound", "", "custom 404 handler (format: package.Handler)")
	flag.Parse()

	if *importPre == "" {
		fmt.Fprintln(os.Stderr, "importPREFIX is required")
		os.Exit(1)
	}

	var routes []route
	routeGroups := make(map[string]bool)

	filepath.WalkDir(*src, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() {
			return err
		}
		if !strings.HasSuffix(d.Name(), ".go") {
			return nil
		}

		fileName := strings.TrimSuffix(d.Name(), ".go")
		method := strings.ToUpper(fileName)

		relDir, err := filepath.Rel(*src, filepath.Dir(path))
		if err != nil {
			return err
		}
		segments := strings.Split(relDir, string(os.PathSeparator))

		var group string
		if len(segments) > 0 && segments[0] != "" {
			group = segments[0]
			routeGroups[group] = true
		}
		if group == "" {
			group = "root"
			routeGroups[group] = true
		}

		var parts []string
		for _, seg := range segments {
			if seg == "" || seg == "index" {
				continue
			}
			if strings.HasPrefix(seg, "[") && strings.HasSuffix(seg, "]") {
				parts = append(parts, "{"+seg[1:len(seg)-1]+"}")
			} else {
				parts = append(parts, seg)
			}
		}
		routePath := "/" + strings.Join(parts, "/")
		if routePath == "/" {
			routePath = "/"
		}

		importPath := strings.TrimSuffix(filepath.ToSlash(filepath.Join(*importPre, relDir)), "/")
		alias := strings.ReplaceAll(relDir, string(os.PathSeparator), "_")
		if alias == "" || alias == "." {
			alias = filepath.Base(*src)
		}

		alias = strings.ReplaceAll(alias, "-", "_")
		alias = strings.ReplaceAll(alias, ".", "_")

		handler := strings.Title(fileName)

		routes = append(routes, route{
			Method:     method,
			RoutePath:  routePath,
			ImportPath: importPath,
			Alias:      alias,
			Handler:    handler,
			Group:      group,
		})
		return nil
	})

	f, err := os.Create(*out)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	tmpl := template.Must(template.New("router").Parse(`// Code generated by fsrouter; DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"net/http"
{{range .Imports}}	{{.Alias}} "{{.Path}}"
{{end}}
	"github.com/gorilla/mux"
)

// RegisterRoutes creates and returns a router with all API routes registered
func RegisterRoutes() *mux.Router {
	r := mux.NewRouter()
	
	// Default 404 handler
	r.NotFoundHandler = http.HandlerFunc({{if .NotFound}}{{.NotFound}}{{else}}defaultNotFoundHandler{{end}})
	
	// Global middleware (applied to all routes)
{{range .Middlewares}}	r.Use({{.}})
{{end}}// Add more global middleware here
	// r.Use(authMiddleware)
	// r.Use(corsMiddleware)
	
{{range $group, $_ := .Groups}}
	// Route group for {{$group}}
	{{$group}}Router := r.PathPrefix("/{{$group}}").Subrouter()
	// Group-specific middleware
{{if index $.GroupMiddlewares $group}}{{range index $.GroupMiddlewares $group}}	{{$group}}Router.Use({{.}})
{{end}}{{else}}	// Add group-specific middleware here if needed
	// {{$group}}Router.Use(someMiddleware){{end}}
{{end}}

{{range .Routes}}	{{if .Group}}{{.Group}}Router{{else}}r{{end}}.HandleFunc("{{.RoutePath}}", {{.Alias}}.{{.Handler}}).Methods("{{.Method}}")
{{end}}

	return r
}

// Default middleware for logging requests
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Printf("%s %s\n", r.Method, r.URL.Path)
		next.ServeHTTP(w, r)
	})
}

{{if not .NotFound}}
// Default 404 handler
func defaultNotFoundHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte(`{"error": "404 not found", "path": "` + r.URL.Path + `"}`))
}
{{end}}
`))

	type importEntry struct {
		Path  string
		Alias string
	}
	imports := []importEntry{}
	importMap := map[string]bool{}

	for _, r := range routes {
		if !importMap[r.ImportPath] {
			imports = append(imports, importEntry{Path: r.ImportPath, Alias: r.Alias})
			importMap[r.ImportPath] = true
		}
	}

	if *middlewarePkg != "" {
		imports = append(imports, importEntry{Path: *middlewarePkg, Alias: "middleware"})
	}

	var notFound string
	if *notFoundHandler != "" {
		notFound = *notFoundHandler
	}

	middlewareList := strings.Split(*middlewares, ",")
	for i, m := range middlewareList {
		middlewareList[i] = strings.TrimSpace(m)
	}

	var groupMiddlewareMap map[string][]string
	if *groupMiddlewares != "" {
		groupMiddlewareMap = make(map[string][]string)
		if err := json.Unmarshal([]byte(*groupMiddlewares), &groupMiddlewareMap); err != nil {
			fmt.Fprintln(os.Stderr, "Error parsing groupMiddlewares JSON:", err)
			os.Exit(1)
		}
	}

	err = tmpl.Execute(f, struct {
		Package          string
		Imports          []importEntry
		Routes           []route
		NotFound         string
		Groups           map[string]bool
		Middlewares      []string
		GroupMiddlewares map[string][]string
	}{
		Package:          *pkg,
		Imports:          imports,
		Routes:           routes,
		NotFound:         notFound,
		Groups:           routeGroups,
		Middlewares:      middlewareList,
		GroupMiddlewares: groupMiddlewareMap,
	})

	if err != nil {
		panic(err)
	}

	fmt.Printf("Generated %s with %d routes in %d groups\n", *out, len(routes), len(routeGroups))
}
